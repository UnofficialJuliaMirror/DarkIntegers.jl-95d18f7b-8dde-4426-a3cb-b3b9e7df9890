var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"CurrentModule = DarkIntegers","category":"page"},{"location":"api.html#Single-limb-arithmetic-1","page":"API reference","title":"Single-limb arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addhilo\nmulhilo\ndivremhilo\ndivhilo\nremhilo","category":"page"},{"location":"api.html#DarkIntegers.addhilo","page":"API reference","title":"DarkIntegers.addhilo","text":"addhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x_hi * B + x_lo + y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T). An overflow in hi (if any) is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulhilo","page":"API reference","title":"DarkIntegers.mulhilo","text":"mulhilo(x::T, y::T) where T <: Unsigned\n\nCalculates hi * B + lo = x * y, where B == typemax(T) + 1. Returns the result as a pair (hi::T, lo::T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divremhilo","page":"API reference","title":"DarkIntegers.divremhilo","text":"divremhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates divrem(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, r::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), r is the remainder is o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.divhilo","page":"API reference","title":"DarkIntegers.divhilo","text":"divhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates div(x_hi * B + x_lo, y), where B == typemax(T) + 1. Returns a tuple (q::T, o::Bool), where q is the quotient (the part of it fitting into the bits of T), and o is the overflow flag.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.remhilo","page":"API reference","title":"DarkIntegers.remhilo","text":"remhilo(x_hi::T, x_lo::T, y::T) where T <: Unsigned\n\nCalculates rem(x_hi * B + x_lo, y), where B == typemax(T) + 1.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Single-limb-modulo-arithmetic-1","page":"API reference","title":"Single-limb modulo arithmetic","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"addmod\nsubmod\nmulmod","category":"page"},{"location":"api.html#DarkIntegers.addmod","page":"API reference","title":"DarkIntegers.addmod","text":"addmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x + y, modulus) (even if x + y overflows T). Assumes x and y are in range 0 ... modulus.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.submod","page":"API reference","title":"DarkIntegers.submod","text":"submod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x - y, modulus) (even if x - y underflows).\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.mulmod","page":"API reference","title":"DarkIntegers.mulmod","text":"mulmod(x::T, y::T, modulus::T) where T <: Unsigned\n\nReturns mod(x * y, modulus) (even if x * y overflows T).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Multi-precision-numbers-1","page":"API reference","title":"Multi-precision numbers","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"MPNumber","category":"page"},{"location":"api.html#DarkIntegers.MPNumber","page":"API reference","title":"DarkIntegers.MPNumber","text":"Multi-precision unsigned integer type, with N limbs of type T (which must be an unsigned integer type).\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd.\n\nMPNumber{N, T}(x::Integer) where {N, T <: Unsigned}\n\nCreates an MPNumber object. If x does not fit into N limbs of type T, the excess bits will be ignored.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Residue-ring-elements-1","page":"API reference","title":"Residue ring elements","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"RRElem","category":"page"},{"location":"api.html#DarkIntegers.RRElem","page":"API reference","title":"DarkIntegers.RRElem","text":"Residue ring element, an unsigned integer with all operations performed modulo M.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nRRElem{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an RRElem object. M must have the type T.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Residue-ring-elements-(Montgomery-representation)-1","page":"API reference","title":"Residue ring elements (Montgomery representation)","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"RRElemMontgomery","category":"page"},{"location":"api.html#DarkIntegers.RRElemMontgomery","page":"API reference","title":"DarkIntegers.RRElemMontgomery","text":"Residue ring element in Montgomery representation. Multiplication is much faster than for RRElem, addition and subtraction are the same, but division and conversion to regular integers is slower.\n\nSupports +, -, *, divrem, div, rem, ^, <, <=, >, >=, zero, one and isodd. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any M).\n\nRRElemMontgomery{T, M}(x::Integer) where {T <: Unsigned, M}\n\nCreates an RRElemMontgomery object. M must have the type T and be an odd number.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Cyclic-polynomials-1","page":"API reference","title":"Cyclic polynomials","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Polynomial\nshift_polynomial","category":"page"},{"location":"api.html#DarkIntegers.Polynomial","page":"API reference","title":"DarkIntegers.Polynomial","text":"Polynomials modulo x^n-1 (cyclic) or x^n+1 (negacyclic). Supports any type that has arithmetic operators defined for it, including RRElem and RRElemMontgomery.\n\nPolynomial(coeffs::AbstractArray{T, 1}, negacyclic::Bool) where T\n\nCreate a polynomial given the array of coefficients (the i-th coefficient corresponds to the (i-1)-th power).\n\n\n\n\n\n","category":"type"},{"location":"api.html#DarkIntegers.shift_polynomial","page":"API reference","title":"DarkIntegers.shift_polynomial","text":"shift_polynomial(p::Polynomial{T}, shift::Integer) where T\n\nMultiply the polynomial by x^shift. shift can be negative.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Partial-modification-of-residue-ring-elements-and-polynomials-1","page":"API reference","title":"Partial modification of residue ring elements and polynomials","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"change_representation\nchange_base_type\nchange_modulus\nchange_length\nrescale","category":"page"},{"location":"api.html#DarkIntegers.change_representation","page":"API reference","title":"DarkIntegers.change_representation","text":"change_representation(\n    new_repr::Union{RRElem, RRElemMontgomery},\n    x::Union{RRElem{T, M}, RRElemMontgomery{T, M}}) where {T, M}\n\nChange the representation of the given residue ring element to one of RRElem, RRElemMontgomery.\n\n\n\n\n\nchange_representation(new_repr, p::Polynomial{T}) where T <: AbstractRRElem\n\nApply change_representation() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_base_type","page":"API reference","title":"DarkIntegers.change_base_type","text":"change_base_type(::Type{V}, x::RRElem{T, M}) where {T, M, V <: Unsigned}\n\nChange the base type (T) of the given residue ring element to the type V. The modulus M must fit into V.\n\n\n\n\n\nchange_base_type(::Type{V}, p::Polynomial{T}) where {T <: AbstractRRElem, V <: Unsigned}\n\nApply change_base_type() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_modulus","page":"API reference","title":"DarkIntegers.change_modulus","text":"change_modulus(new_modulus::Unsigned, x::RRElem{T, M}) where {T, M}\n\nChange modulus to new_modulus (it will be converted to type T), keeping the value intact. If the new modulus is smaller than the current one, the value will be taken modulo new_modulus.\n\n\n\n\n\nchange_modulus(new_modulus::Unsigned, p::Polynomial{T}) where T <: AbstractRRElem\n\nApply change_modulus() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.change_length","page":"API reference","title":"DarkIntegers.change_length","text":"change_length(new_length::Integer, p::Polynomial)\n\nChange length of the polynomial, padding it with zeros. The new length must be greater or equal to the current length.\n\n\n\n\n\n","category":"function"},{"location":"api.html#DarkIntegers.rescale","page":"API reference","title":"DarkIntegers.rescale","text":"rescale(new_max::Unsigned, x::RRElem{T, M}, round_result::Bool)\n\nRescale x proportionally to the range [0, new_max) (where new_max <= M). Equivalent to floor(x * new_max / M) or round(...), depending on the value of round_result. If round_result is true, and the value if equal to new_max after rounding, it is set to 0.\n\n\n\n\n\nrescale(new_max::Unsigned, p::Polynomial{T}, round_result::Bool) where T <: RRElem\n\nApply rescale() to every coefficient of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Miscellaneous-1","page":"API reference","title":"Miscellaneous","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"encompassing_type","category":"page"},{"location":"api.html#DarkIntegers.encompassing_type","page":"API reference","title":"DarkIntegers.encompassing_type","text":"encompassing_type(tp::Unsigned)\n\nReturns the built-in type that covers all the range of tp. Works on UInt*, MPNumber, RRElem and RRElemMontgomery.\n\n\n\n\n\n","category":"function"},{"location":"history.html#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history.html#v0.0.1-1","page":"Version history","title":"v0.0.1","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"Initial version.","category":"page"},{"location":"manual.html#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"In this section we assume that every example is preceded with","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"using DarkIntegers","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using DarkIntegers\nend","category":"page"},{"location":"manual.html#Multi-precision-numbers-1","page":"Manual","title":"Multi-precision numbers","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The basic facility in DarkIntegers are multi-precision unsigned integers MPNumber{N, T}. The type takes two parameters, N (an integer) being the number of limbs, or digits, and T (an unsigned integer type) is the type of a limb. Its functionality is closer to that of BigInt, but MPNumber still has fixed length (although it can be much greater than what any Julia built-in type supports). On the other hand, operations with it do not require dynamic memory allocation and are faster than the BigInt ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The MPNumber constructor takes any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MPNumber{2, UInt8}(65534)\nprintln(a)\n\n# output\n\n{(0xfe, 0xff)}","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note that the limbs are arranged in the big-endian order.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"A multi-precision number can be converted back to any integer:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"b = convert(Int, a)\nprintln(b)\n\n# output\n\n65534","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Multi-precision numbers support arithmetic operations and comparisons and act identically to built-in unsigned integer types:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"a = MPNumber{2, UInt8}(65534)\nb = MPNumber{2, UInt8}(65533)\nprintln(a + b)\nprintln(convert(Int, a + b))\n\n# output\n{(0xfb, 0xff)}\n65531","category":"page"},{"location":"manual.html#Residue-ring-elements-1","page":"Manual","title":"Residue ring elements","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The next level above multi-precision integers (and built-in unsigned integers) are residue ring elements, that is, unsigned integers with the arithmetic operations performed modulo some number. The residue ring element type RRElem{T, M} is parametrized by the number type T (an unsigned integer) and the modulus M (which is a value of type T).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Similarly to MPNumber objects, RRElem objects can be constructed out of an integer. If the integer is greater than the modulus, it will be truncated (by applying mod()):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(200)\na = RRElem{UInt8, modulus}(250)\nprintln(a)\n\n# output\n50RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"All arithmetic operations on RRElem objects are performed modulo modulus. Any regular integers in mixed expressions are promoted to RRElem objects:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(a + 101)\n\n# output\n151RR","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"RRElem objects can be converted back to integers:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(convert(Int, a))\n\n# output\n50","category":"page"},{"location":"manual.html#Montgomery-representation-1","page":"Manual","title":"Montgomery representation","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Residue ring elements can be converted to an alternate representation, which makes use of Montgomery reduction for multiplication. As a result, the multiplication becomes much faster, addition and subtraction stay the same, and division (and conversion to and from integers) become slower. The representation implemented as the type RRElemMontgomery{T, M}, which is parametrized in the same way as RRElem. Depending on the relative amount of different arithmetic operations one needs to perform, either RRElem or RRElemMontgomery may perform better.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The interface is the same as the one for RRElem, except for the restriction on M to be an odd number:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(201)\na = RRElemMontgomery{UInt8, modulus}(250)\nprintln(a)\nprintln(convert(Int, a + 101))\n\n# output\n49RRM\n150","category":"page"},{"location":"manual.html#Cyclic-polynomials-1","page":"Manual","title":"Cyclic polynomials","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Anything type supporting arithmetic operations (including MPNumber, RRElem and RRElemMontgomery) can serve as the coefficient type in the Polynomial type. DarkIntegers supports cyclic polynomials (with operations performed modulo x^n-1, where n is some non-negative integer called the length of the polynomial) and negacyclic ones (with operations performed modulo x^n+1).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Polynomials are created out of a coefficient array (where the i-th element corresponds to the (i-1)-th power of x) and the negacyclicity flag:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"p = Polynomial([1, 2, 3, 4], true) # creates a negacyclic polynomial\nprintln(p)\nprintln(p + 1)\nprintln(p * 2)\n\n# output\nPolynomial{Int64}([1, 2, 3, 4], true, DarkIntegers.karatsuba_mul)\nPolynomial{Int64}([2, 2, 3, 4], true, DarkIntegers.karatsuba_mul)\nPolynomial{Int64}([2, 4, 6, 8], true, DarkIntegers.karatsuba_mul)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The polynomial can be multiplied by a power of x using shift_polynomial. Since the polynomial we created is cyclic, the coefficients with the powers greater or equal to n will reappear from the other side with the opposite sign (one can work it out by applying the x^n+1 modulus manually):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"println(shift_polynomial(p, 2))\n\n# output\nPolynomial{Int64}([-3, -4, 1, 2], true, DarkIntegers.karatsuba_mul)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note the multiplication function that is the part of the Polynomial structure. The default for the multiplication is Karatsuba algorithm; if possible a more faster NTT-based algorithm will be chosen. It requires:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"the coefficient type to be a residue ring element (RRElem or RRElemMontgomery) with a prime modulus;\nthe length of the polynomial to be a power of 2;\nthe length of the polynomial to be a factor of (modulus - 1) for cyclic polynomials, and (modulus - 1)/2 for negacyclic ones.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"For example:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"modulus = UInt8(241)\ntp = RRElem{UInt8, modulus}\np1 = Polynomial(tp[1, 2, 3, 4], true)\np2 = Polynomial(tp[1, 0, 1, 0], true)\nprintln(p1)\nprintln(p2)\nprintln(p1 * p2)\n\n# output\nPolynomial{RRElem{UInt8,0xf1}}(RRElem{UInt8,0xf1}[1RR, 2RR, 3RR, 4RR], true, DarkIntegers.ntt_mul)\nPolynomial{RRElem{UInt8,0xf1}}(RRElem{UInt8,0xf1}[1RR, 0RR, 1RR, 0RR], true, DarkIntegers.ntt_mul)\nPolynomial{RRElem{UInt8,0xf1}}(RRElem{UInt8,0xf1}[239RR, 239RR, 4RR, 6RR], true, DarkIntegers.ntt_mul)","category":"page"},{"location":"index.html#Dark-Integers,-an-unsigned-integer-arithmetic-toolbox-1","page":"Home","title":"Dark Integers, an unsigned integer arithmetic toolbox","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"DarkIntegers.jl is a pure Julia implementation of unsigned integer modulo arithmetic for simple and multi-precision (arbitrary long) integers. Functionally, it is a subset of Nemo, but unlike it, DarkIntegers does not use external C libraries. In particular, it implements Montgomery representation of integers, allowing for efficient modulo multiplication. Also it has a slightly simpler interface, and does not show any messages on import.","category":"page"}]
}
