<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · DarkIntegers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DarkIntegers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="manual.html">Manual</a></li><li class="current"><a class="toctext" href="api.html">API reference</a><ul class="internal"><li><a class="toctext" href="#Single-limb-arithmetic-1">Single-limb arithmetic</a></li><li><a class="toctext" href="#Single-limb-modulo-arithmetic-1">Single-limb modulo arithmetic</a></li><li><a class="toctext" href="#Multi-precision-numbers-1">Multi-precision numbers</a></li><li><a class="toctext" href="#Residue-ring-elements-1">Residue ring elements</a></li><li><a class="toctext" href="#Residue-ring-elements-(Montgomery-representation)-1">Residue ring elements (Montgomery representation)</a></li><li><a class="toctext" href="#Cyclic-polynomials-1">Cyclic polynomials</a></li><li><a class="toctext" href="#Partial-modification-of-residue-ring-elements-and-polynomials-1">Partial modification of residue ring elements and polynomials</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="history.html">Version history</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API reference</a></li></ul><a class="edit-page" href="https://github.com/nucypher/DarkIntegers.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-reference-1" href="#API-reference-1">API reference</a></h1><h2><a class="nav-anchor" id="Single-limb-arithmetic-1" href="#Single-limb-arithmetic-1">Single-limb arithmetic</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.addhilo" href="#DarkIntegers.addhilo"><code>DarkIntegers.addhilo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addhilo(x_hi::T, x_lo::T, y::T) where T &lt;: Unsigned</code></pre><p>Calculates <code>hi * B + lo = x_hi * B + x_lo + y</code>, where <code>B == typemax(T) + 1</code>. Returns the result as a pair <code>(hi::T, lo::T)</code>. An overflow in <code>hi</code> (if any) is ignored.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb.jl#L33-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.mulhilo" href="#DarkIntegers.mulhilo"><code>DarkIntegers.mulhilo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mulhilo(x::T, y::T) where T &lt;: Unsigned</code></pre><p>Calculates <code>hi * B + lo = x * y</code>, where <code>B == typemax(T) + 1</code>. Returns the result as a pair <code>(hi::T, lo::T)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb.jl#L92-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.divremhilo" href="#DarkIntegers.divremhilo"><code>DarkIntegers.divremhilo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">divremhilo(x_hi::T, x_lo::T, y::T) where T &lt;: Unsigned</code></pre><p>Calculates <code>divrem(x_hi * B + x_lo, y)</code>, where <code>B == typemax(T) + 1</code>. Returns a tuple <code>(q::T, r::T, o::Bool)</code>, where <code>q</code> is the quotient (the part of it fitting into the bits of <code>T</code>), <code>r</code> is the remainder is <code>o</code> is the overflow flag.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb.jl#L163-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.divhilo" href="#DarkIntegers.divhilo"><code>DarkIntegers.divhilo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">divhilo(x_hi::T, x_lo::T, y::T) where T &lt;: Unsigned</code></pre><p>Calculates <code>div(x_hi * B + x_lo, y)</code>, where <code>B == typemax(T) + 1</code>. Returns a tuple <code>(q::T, o::Bool)</code>, where <code>q</code> is the quotient (the part of it fitting into the bits of <code>T</code>), and <code>o</code> is the overflow flag.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb.jl#L179-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.remhilo" href="#DarkIntegers.remhilo"><code>DarkIntegers.remhilo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remhilo(x_hi::T, x_lo::T, y::T) where T &lt;: Unsigned</code></pre><p>Calculates <code>rem(x_hi * B + x_lo, y)</code>, where <code>B == typemax(T) + 1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb.jl#L192-L196">source</a></section><h2><a class="nav-anchor" id="Single-limb-modulo-arithmetic-1" href="#Single-limb-modulo-arithmetic-1">Single-limb modulo arithmetic</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.addmod" href="#DarkIntegers.addmod"><code>DarkIntegers.addmod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">addmod(x::T, y::T, modulus::T) where T &lt;: Unsigned</code></pre><p>Returns <code>mod(x + y, modulus)</code> (even if <code>x + y</code> overflows <code>T</code>). Assumes <code>x</code> and <code>y</code> are in range <code>0 ... modulus</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb_modulo.jl#L6-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.submod" href="#DarkIntegers.submod"><code>DarkIntegers.submod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">submod(x::T, y::T, modulus::T) where T &lt;: Unsigned</code></pre><p>Returns <code>mod(x - y, modulus)</code> (even if <code>x - y</code> underflows).</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb_modulo.jl#L44-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.mulmod" href="#DarkIntegers.mulmod"><code>DarkIntegers.mulmod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mulmod(x::T, y::T, modulus::T) where T &lt;: Unsigned</code></pre><p>Returns <code>mod(x * y, modulus)</code> (even if <code>x * y</code> overflows <code>T</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/single_limb_modulo.jl#L123-L127">source</a></section><h2><a class="nav-anchor" id="Multi-precision-numbers-1" href="#Multi-precision-numbers-1">Multi-precision numbers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.MPNumber" href="#DarkIntegers.MPNumber"><code>DarkIntegers.MPNumber</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Multi-precision unsigned integer type, with <code>N</code> limbs of type <code>T</code> (which must be an unsigned integer type).</p><p>Supports <code>+</code>, <code>-</code>, <code>*</code>, <code>divrem</code>, <code>div</code>, <code>rem</code>, <code>^</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>zero</code>, <code>one</code> and <code>isodd</code>.</p><pre><code class="language-none">MPNumber{N, T}(x::Integer) where {N, T &lt;: Unsigned}</code></pre><p>Creates an <code>MPNumber</code> object. If <code>x</code> does not fit into <code>N</code> limbs of type <code>T</code>, the excess bits will be ignored.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/mp_number.jl#L8-L19">source</a></section><h2><a class="nav-anchor" id="Residue-ring-elements-1" href="#Residue-ring-elements-1">Residue ring elements</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.RRElem" href="#DarkIntegers.RRElem"><code>DarkIntegers.RRElem</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Residue ring element, an unsigned integer with all operations performed modulo <code>M</code>.</p><p>Supports <code>+</code>, <code>-</code>, <code>*</code>, <code>divrem</code>, <code>div</code>, <code>rem</code>, <code>^</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>zero</code>, <code>one</code> and <code>isodd</code>. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any <code>M</code>).</p><pre><code class="language-none">RRElem{T, M}(x::Integer) where {T &lt;: Unsigned, M}</code></pre><p>Creates an <code>RRElem</code> object. <code>M</code> must have the type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/residue_ring.jl#L10-L21">source</a></section><h2><a class="nav-anchor" id="Residue-ring-elements-(Montgomery-representation)-1" href="#Residue-ring-elements-(Montgomery-representation)-1">Residue ring elements (Montgomery representation)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.RRElemMontgomery" href="#DarkIntegers.RRElemMontgomery"><code>DarkIntegers.RRElemMontgomery</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Residue ring element in Montgomery representation. Multiplication is much faster than for <a href="api.html#DarkIntegers.RRElem"><code>RRElem</code></a>, addition and subtraction are the same, but division and conversion to regular integers is slower.</p><p>Supports <code>+</code>, <code>-</code>, <code>*</code>, <code>divrem</code>, <code>div</code>, <code>rem</code>, <code>^</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>zero</code>, <code>one</code> and <code>isodd</code>. Note that the division is a regular division, not multiplication by the inverse (which is not guaranteed to exist for any <code>M</code>).</p><pre><code class="language-none">RRElemMontgomery{T, M}(x::Integer) where {T &lt;: Unsigned, M}</code></pre><p>Creates an <code>RRElemMontgomery</code> object. <code>M</code> must have the type <code>T</code> and be an odd number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/residue_ring_montgomery.jl#L7-L20">source</a></section><h2><a class="nav-anchor" id="Cyclic-polynomials-1" href="#Cyclic-polynomials-1">Cyclic polynomials</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.Polynomial" href="#DarkIntegers.Polynomial"><code>DarkIntegers.Polynomial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Polynomials modulo <code>x^n-1</code> (cyclic) or <code>x^n+1</code> (negacyclic). Supports any type that has arithmetic operators defined for it, including <a href="api.html#DarkIntegers.RRElem"><code>RRElem</code></a> and <a href="api.html#DarkIntegers.RRElemMontgomery"><code>RRElemMontgomery</code></a>.</p><pre><code class="language-none">Polynomial(coeffs::AbstractArray{T, 1}, negacyclic::Bool) where T</code></pre><p>Create a polynomial given the array of coefficients (the <code>i</code>-th coefficient corresponds to the <code>(i-1)</code>-th power).</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/polynomial.jl#L26-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.shift_polynomial" href="#DarkIntegers.shift_polynomial"><code>DarkIntegers.shift_polynomial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">shift_polynomial(p::Polynomial{T}, shift::Integer) where T</code></pre><p>Multiply the polynomial by <code>x^shift</code>. <code>shift</code> can be negative.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/polynomial.jl#L143-L147">source</a></section><h2><a class="nav-anchor" id="Partial-modification-of-residue-ring-elements-and-polynomials-1" href="#Partial-modification-of-residue-ring-elements-and-polynomials-1">Partial modification of residue ring elements and polynomials</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.change_representation" href="#DarkIntegers.change_representation"><code>DarkIntegers.change_representation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">change_representation(
    new_repr::Union{RRElem, RRElemMontgomery},
    x::Union{RRElem{T, M}, RRElemMontgomery{T, M}}) where {T, M}</code></pre><p>Change the representation of the given residue ring element to one of <a href="api.html#DarkIntegers.RRElem"><code>RRElem</code></a>, <a href="api.html#DarkIntegers.RRElemMontgomery"><code>RRElemMontgomery</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L56-L63">source</a><div><div><pre><code class="language-none">change_representation(new_repr, p::Polynomial{T}) where T &lt;: AbstractRRElem</code></pre><p>Apply <code>change_representation()</code> to every coefficient of the polynomial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L73-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.change_base_type" href="#DarkIntegers.change_base_type"><code>DarkIntegers.change_base_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">change_base_type(::Type{V}, x::RRElem{T, M}) where {T, M, V &lt;: Unsigned}</code></pre><p>Change the base type (<code>T</code>) of the given residue ring element to the type <code>V</code>. The modulus <code>M</code> must fit into <code>V</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L82-L87">source</a><div><div><pre><code class="language-none">change_base_type(::Type{V}, p::Polynomial{T}) where {T &lt;: AbstractRRElem, V &lt;: Unsigned}</code></pre><p>Apply <code>change_base_type()</code> to every coefficient of the polynomial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L99-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.change_modulus" href="#DarkIntegers.change_modulus"><code>DarkIntegers.change_modulus</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">change_modulus(new_modulus::Unsigned, x::RRElem{T, M}) where {T, M}</code></pre><p>Change modulus to <code>new_modulus</code> (it will be converted to type <code>T</code>), keeping the value intact. If the new modulus is smaller than the current one, the value will be taken modulo <code>new_modulus</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L28-L33">source</a><div><div><pre><code class="language-none">change_modulus(new_modulus::Unsigned, p::Polynomial{T}) where T &lt;: AbstractRRElem</code></pre><p>Apply <code>change_modulus()</code> to every coefficient of the polynomial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L43-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.change_length" href="#DarkIntegers.change_length"><code>DarkIntegers.change_length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">change_length(new_length::Integer, p::Polynomial)</code></pre><p>Change length of the polynomial, padding it with zeros. The new length must be greater or equal to the current length.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L151-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.rescale" href="#DarkIntegers.rescale"><code>DarkIntegers.rescale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rescale(new_max::Unsigned, x::RRElem{T, M}, round_result::Bool)</code></pre><p>Rescale <code>x</code> proportionally to the range <code>[0, new_max)</code> (where <code>new_max &lt;= M</code>). Equivalent to <code>floor(x * new_max / M)</code> or <code>round(...)</code>, depending on the value of <code>round_result</code>. If <code>round_result</code> is <code>true</code>, and the value if equal to <code>new_max</code> after rounding, it is set to 0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L127-L133">source</a><div><div><pre><code class="language-none">rescale(new_max::Unsigned, p::Polynomial{T}, round_result::Bool) where T &lt;: RRElem</code></pre><p>Apply <code>rescale()</code> to every coefficient of the polynomial.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/modification.jl#L140-L144">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DarkIntegers.encompassing_type" href="#DarkIntegers.encompassing_type"><code>DarkIntegers.encompassing_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">encompassing_type(tp::Unsigned)</code></pre><p>Returns the built-in type that covers all the range of <code>tp</code>. Works on <code>UInt*</code>, <a href="api.html#DarkIntegers.MPNumber"><code>MPNumber</code></a>, <a href="api.html#DarkIntegers.RRElem"><code>RRElem</code></a> and <a href="api.html#DarkIntegers.RRElemMontgomery"><code>RRElemMontgomery</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/nucypher/DarkIntegers.jl/blob/2d1af92a59af6a6a1b7ac653760d032884c5a550/src/misc.jl#L1-L6">source</a></section><footer><hr/><a class="previous" href="manual.html"><span class="direction">Previous</span><span class="title">Manual</span></a><a class="next" href="history.html"><span class="direction">Next</span><span class="title">Version history</span></a></footer></article></body></html>
